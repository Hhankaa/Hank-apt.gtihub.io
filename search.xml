<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SecretWorld</title>
    <url>/2021/06/20/SecretWorld/</url>
    <content><![CDATA[<p>#你为什么来到这里？<br>– 关于这里的一切，这里是我的秘密基地；<br>#今天还是觉得有点枯燥<br>– 为什么没有一些值得我做的事情？还不如在学校学习东西。</p>
]]></content>
  </entry>
  <entry>
    <title>1.动态规划</title>
    <url>/2021/06/28/1.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>动态规划，包含3个重要的概念： 1. 最优子结构 2. 边界3. 状态方程</strong></p>
<p>思考问题： 如何优化动态规划问题？如果dp[i] 只和dp[i-1]有关，那么可以使用【滚动变量】的方式将代码进行优化。</p>
<ul>
<li>当前状态至于前两个状态有关，只需要想办法存储前两个状态就可以了。</li>
</ul>
<h2 id="1-53-最大子序和"><a href="#1-53-最大子序和" class="headerlink" title="1. 53. 最大子序和"></a>1. <a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2><ul>
<li><p><code>dp[i]</code>：表示以 <code>nums[i]</code> **结尾的 <strong>连续</strong> 子数组的最大和。</p>
</li>
<li><p>状态转移方程<br>$$<br>dp[i]=\left{<br>\begin{aligned}<br>dp[i-1]+nums[i] &amp; &amp; dp[i-1]&gt;=0\<br>nums[i] &amp; &amp; dp&lt; 0<br>\end{aligned}<br>\right.<br>$$</p>
<p>$$<br>dp[i] = max(dp[i-1]+nums[i],nums[i])<br>$$</p>
</li>
<li><p>思考初始问题： dp[0 ] = nums[0].</p>
</li>
</ul>
<pre><code class="python">def maxSubArray(nums):
    if len(nums) == 0: return 0
    dp = [0 for _ in range(len(nums))]
    dp[0] = nums[0]
    for i in range(len(nums)):
        dp[i] = max(dp[i-1]+nums[i],nums[i])
    return max(dp)
def maxSubArray(nums):
    if len(nums) == 0: return 0
    pre = nums[0]
    res = 0
    for i in range(len(nums)):
        pre = max(pre+nums[i],nums[i])
        res = max(res,pre)
    return res
</code></pre>
<h2 id="2-322-零钱兑换"><a href="#2-322-零钱兑换" class="headerlink" title="2. 322. 零钱兑换"></a>2. <a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h2><p>​    <strong>步骤：</strong></p>
<ol>
<li>确定base case </li>
<li>确定【状态】，也就是原问题和子问题中会变化的变量</li>
<li>确定【选择】，也就是导致【状态】产生变化的行为</li>
<li>明确dp函数/数组的定义</li>
</ol>
<img src="https://pic.leetcode-cn.com/2cdf411d73e7f4990c63c9ff69847c146311689ebc286d3eae715fa5c53483cf-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-03-08%2010.23.03.png" style="zoom:50%;" />

<h2 id="3-121-买卖股票的最佳时机"><a href="#3-121-买卖股票的最佳时机" class="headerlink" title="3. 121. 买卖股票的最佳时机"></a>3. <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p><strong>买一次，卖一次</strong>，max-min 就可以得到最大的利润，那就要得到这个<strong>最小值</strong>，遍历整个list，每次都与当前的最小值相减，得到当前的最大值即可。</p>
<pre><code class="Python">  def maxProfit(self, prices: List[int]) -&gt; int:
        n = len(prices)
        if n &lt; 0 : return 0
        dp = [0]*n
        minPrice = prices[0]

        for i in range(n):
            minPrice = min(prices[i],minPrice)
            dp[i] = max(dp[i-1],prices[i]-minPrice)
        return max(dp)
</code></pre>
<p>因为dp[i] 只和 dp[i-1]有关，所以可以进行状态压缩</p>
<pre><code class="Python">    def maxProfit(self, prices: List[int]) -&gt; int:
        n = len(prices)
        if n &lt; 0 : return 0
        minPrice = prices[0]
        maxProfit = 0
        for i in range(n):
            minPrice = min(prices[i],minPrice)
            maxProfit = max(maxProfit,prices[i]-minPrice)
        return maxProfit
</code></pre>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
